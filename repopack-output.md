This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-12-31T08:51:16.112Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repopack, visit: https://github.com/yamadashy/repopack

# Repository Structure
```
command_handler.py
commands.py
config.py
dj_core.py
log.py
lyrics_sync.py
main.py
player.py
ui.py
wait_games.py
```

# Repository Files

## File: command_handler.py
```python
import shlex
from rich.console import Console
from rich.table import Table

# å…¨å±€ Console å¯¹è±¡ï¼Œä¿è¯è¾“å‡ºç»Ÿä¸€
console = Console()

class Context:
    """
    ä¸Šä¸‹æ–‡å¯¹è±¡ï¼šæŒæœ‰æ‰€æœ‰ç³»ç»Ÿç»„ä»¶çš„çŠ¶æ€ã€‚
    è¢«ä¼ é€’ç»™æ¯ä¸€ä¸ªå‘½ä»¤å‡½æ•°ã€‚
    """
    def __init__(self, aidj, dbus, config, play_list=None):
        self.aidj = aidj
        self.dbus = dbus
        self.config = config
        self.play_list = play_list or [] # å…¨å±€æ’­æ”¾åˆ—è¡¨
        self.console = console

class CommandRegistry:
    """å‘½ä»¤æ³¨å†Œä¸åˆ†å‘å™¨"""
    def __init__(self):
        self.commands = {}
        self.descriptions = {}

    def register(self, *names):
        """è£…é¥°å™¨ï¼šæ³¨å†Œå‘½ä»¤"""
        def decorator(func):
            for name in names:
                self.commands[name.lower()] = func
            desc = (func.__doc__ or "No description").strip().split('\n')[0]
            self.descriptions[names[0]] = desc
            return func
        return decorator

    def dispatch(self, raw_input, ctx: Context):
        """è§£æå¹¶æ‰§è¡Œå‘½ä»¤"""
        if not raw_input.strip():
            return

        try:
            parts = shlex.split(raw_input)
        except ValueError:
            console.print("[red]âŒ Error: Unmatched quotes in command.[/]")
            return

        cmd_name = parts[0].lower()
        args = parts[1:]

        if cmd_name in self.commands:
            try:
                self.commands[cmd_name](ctx, *args)
            except Exception as e:
                console.print(f"[red]âŒ Execution Error: {e}[/]")
                # import traceback; traceback.print_exc() # Debug
        else:
            console.print(f"[red]â“ Unknown command: '{cmd_name}'. Type 'help' for list.[/]")

    def get_command_list(self):
        return list(self.commands.keys())

    def print_help(self):
        # å®šä¹‰ 4 åˆ—çš„è¡¨æ ¼ (Cmd | Desc || Cmd | Desc)
        t = Table(title="ğŸ“œ Command Reference", show_lines=True, expand=True)
        
        # ç¬¬ä¸€ç»„åˆ—
        t.add_column("Command", style="cyan", no_wrap=True)
        t.add_column("Description", style="white")
        
        # ç¬¬äºŒç»„åˆ— (ä¸­é—´åŠ ä¸ªç©ºåˆ—æˆ–è€…ç›´æ¥å¹¶æ’ï¼Œè¿™é‡Œç›´æ¥å¹¶æ’)
        t.add_column("Command", style="cyan", no_wrap=True)
        t.add_column("Description", style="white")

        # è·å–æ‰€æœ‰æ’åºåçš„ (å‘½ä»¤, æè¿°) å…ƒç»„
        items = sorted(self.descriptions.items())

        # æ¯æ¬¡å– 2 ä¸ªè¿›è¡Œå¾ªç¯ (æ­¥é•¿ä¸º 2)
        for i in range(0, len(items), 2):
            # å·¦è¾¹çš„å‘½ä»¤
            cmd1, desc1 = items[i]
            
            # å³è¾¹çš„å‘½ä»¤ (æ£€æŸ¥æ˜¯å¦å­˜åœ¨ï¼Œå› ä¸ºæ€»æ•°å¯èƒ½æ˜¯å¥‡æ•°)
            if i + 1 < len(items):
                cmd2, desc2 = items[i+1]
            else:
                # å¦‚æœæ˜¯å¥‡æ•°ä¸ªï¼Œæœ€åä¸€è¡Œå³è¾¹ç•™ç©º
                cmd2, desc2 = "", ""

            t.add_row(cmd1, desc1, cmd2, desc2)

        console.print(t) 

# å…¨å±€å•ä¾‹æ³¨å†Œè¡¨
registry = CommandRegistry()
```

## File: commands.py
```python
import os
import json
import random
import time
import glob
import dbus
import re
import requests 
from rich.live import Live
from rich.align import Align
from rich.panel import Panel
import questionary
from rapidfuzz import process, fuzz
from config import save_config, PLAYLIST_DIR, SEPARATOR, LANGUAGE, LYRICS_DIR, NCM_BASE_URL
from player import execute_player_command
from command_handler import registry, console, Context
import ui

# --- Helper Logic ---
def _update_playlist_and_trigger(ctx: Context, new_playlist, intro, title_desc):
    """æ›´æ–°ä¸Šä¸‹æ–‡ä¸­çš„æ’­æ”¾åˆ—è¡¨ï¼Œæ‰“å°è¡¨æ ¼ï¼Œå¹¶æ‰§è¡Œè‡ªåŠ¨è§¦å‘"""
    if intro:
        ui.print_dj_intro(intro)
    
    if not new_playlist:
        if not intro: console.print("[yellow]No matches found.[/]")
        return

    # Update Global State
    ctx.play_list = new_playlist
    
    # Print UI
    ui.print_playlist(new_playlist, ctx.aidj.metadata, title_desc)

    # Auto Trigger
    trigger = ctx.config['preferences'].get('saved_trigger')
    if trigger:
        console.print(f"[yellow]âš¡ Auto-Executing: {trigger}[/]")
        execute_player_command(trigger, ctx.play_list, ctx.dbus)

def _player_helper(ctx, cmd):
    """Player command wrapper"""
    execute_player_command(cmd, ctx.play_list if cmd in ['mpv','vlc','send'] else None, ctx.dbus)

# --- System Commands ---

@registry.register("exit", "quit", "q")
def cmd_exit(ctx: Context, *args):
    """Exit the application."""
    console.print("[bold red]ğŸ‘‹ See ya![/]")
    raise SystemExit

@registry.register("help", "?")
def cmd_help(ctx: Context, *args):
    """Show this help message."""
    registry.print_help()

@registry.register("status", "check", "conf")
def cmd_status(ctx: Context, *args):
    """Show system configuration and status."""
    ui.print_status(ctx.config, ctx.config.get('ai_settings', {}), len(ctx.play_list))

@registry.register("verbose")
def cmd_verbose(ctx: Context, *args):
    """Toggle verbose logging mode."""
    curr = ctx.config['preferences']['verbose']
    ctx.config['preferences']['verbose'] = not curr
    save_config(ctx.config)
    ctx.aidj.config = ctx.config # Update instance config
    console.print(f"[green]ğŸ“ Verbose Mode: {not curr}[/]")

@registry.register("refresh")
def cmd_refresh(ctx: Context, *args):
    """Refresh session history (keep songs)."""
    ctx.aidj.refresh(clear_history=False)

@registry.register("reset")
def cmd_reset(ctx: Context, *args):
    """Reset session history and played songs memory."""
    ctx.aidj.refresh(clear_history=True)

@registry.register("auto")
def cmd_auto(ctx: Context, *args):
    """Set persistent auto-trigger command (e.g. 'auto mpv')."""
    if not args:
        curr = ctx.config['preferences'].get('saved_trigger')
        console.print(f"[yellow]Current Trigger: {curr or 'None'}[/]")
        return
    
    val = args[0].lower()
    if val in ["off", "none", "stop"]:
        ctx.config['preferences']['saved_trigger'] = None
        console.print("[green]âš¡ Auto Trigger Disabled[/]")
    else:
        ctx.config['preferences']['saved_trigger'] = val
        console.print(f"[green]âš¡ Auto Trigger Set: {val}[/]")
    save_config(ctx.config)

@registry.register("model")
def cmd_model(ctx: Context, *args):
    """Switch AI Model."""
    avail = ctx.config['ai_settings'].get("available_models", ["deepseek-chat"])
    curr = ctx.config['preferences']['model']
    sel = questionary.select("Switch Model:", choices=avail, default=curr).ask()
    if sel:
        ctx.config['preferences']['model'] = sel
        save_config(ctx.config)
        ctx.aidj.config = ctx.config
        console.print(f"[green]ğŸ§  Model Switched to: {sel}[/]")

@registry.register("show")
def cmd_show(ctx: Context, *args):
    """Inspect metadata: show <song_name>."""
    if not args:
        console.print("[red]Usage: show <song name>[/]")
        return
    query = " ".join(args)
    keys = list(ctx.aidj.metadata.keys())
    result = process.extractOne(query, keys, scorer=fuzz.token_sort_ratio)
    if not result or result[1] < 60:
        console.print(f"[red]âŒ Song '{query}' not found.[/]")
        return
    ui.print_metadata(result[0], ctx.aidj.metadata[result[0]])

# --- Generator Commands ---

@registry.register("r")
def cmd_random(ctx: Context, *args):
    """Select N random songs: r <count>."""
    if not args or not args[0].isdigit():
        console.print("[red]Usage: r <number>[/]")
        return
    count = int(args[0])
    all_keys = list(ctx.aidj.music_paths.keys())
    
    if count <= 0:
        console.print("[yellow]Please select at least 1 song.[/]")
        return

    if count > 50:
        count = 50
        console.print(f"[dim]âš ï¸ Capped at 50 songs.[/]")
    
    if count > len(all_keys): count = len(all_keys)
    
    selected = random.sample(all_keys, count)
    pl = [{"name": k, "path": ctx.aidj.music_paths[k]} for k in selected]
    
    console.print(f"[green]ğŸ² Randomly selected {len(pl)} tracks.[/]")
    _update_playlist_and_trigger(ctx, pl, None, "Random Selection")

@registry.register("pr")
def cmd_prompt_random(ctx: Context, *args):
    """AI curated random selection: pr <count>."""
    if not args or not args[0].isdigit():
        console.print("[red]Usage: pr <number>[/]")
        return
    count = int(args[0])
    count = min(count, 50) 
    all_keys = list(ctx.aidj.music_paths.keys())
    
    if count <= 0: return

    if count > len(all_keys): count = len(all_keys)
    
    random_keys = random.sample(all_keys, count)
    min_keep = max(1, count // 2)
    candidates_str = json.dumps(random_keys, ensure_ascii=False)
    
    system_req = (
        f"System Request: I have randomly picked {count} candidate songs from the library: {candidates_str}.\n"
        f"Task: Curate a coherent playlist from THIS SPECIFIC LIST.\n"
        f"Rules: 1. Sort for flow. 2. Filter clashes. 3. Keep at least {min_keep} songs. 4. No hallucinations.\n"
        f"5. Write in {LANGUAGE}. 6. Intro BEFORE separator, keys AFTER."
    )
    
    pl, intro = ctx.aidj.next_step(system_req)
    if not pl: 
         console.print("[yellow]AI curation failed, falling back to raw selection.[/]")
         pl = [{"name": k, "path": ctx.aidj.music_paths[k]} for k in random_keys]
    
    _update_playlist_and_trigger(ctx, pl, intro, "AI Curated Random")

@registry.register("p", "prompt", "gen")
def cmd_gen(ctx: Context, *args):
    """Generate playlist from text: p <request>."""
    if not args:
        console.print("[red]Usage: p <text>[/]")
        return
    request = " ".join(args)
    pl, intro = ctx.aidj.next_step(request)
    _update_playlist_and_trigger(ctx, pl, intro, "AI Generated")

# --- Player & DBus Commands ---
# ä¸ºäº†æ˜ç¡®åŠŸèƒ½ï¼Œè¿™é‡Œåˆ†åˆ«æ³¨å†Œï¼Œä½†ç»Ÿä¸€è°ƒç”¨è¾…åŠ©å‡½æ•°

@registry.register("next", "n")
def _c_next(ctx: Context, *args):
    """Play next track."""
    _player_helper(ctx, "next")

@registry.register("prev", "b")
def _c_prev(ctx: Context, *args):
    """Play previous track."""
    _player_helper(ctx, "prev")

@registry.register("play")
def _c_play(ctx: Context, *args):
    """Resume playback."""
    _player_helper(ctx, "play")

@registry.register("pause")
def _c_pause(ctx: Context, *args):
    """Pause playback."""
    _player_helper(ctx, "pause")

@registry.register("toggle")
def _c_toggle(ctx: Context, *args):
    """Toggle play/pause."""
    _player_helper(ctx, "toggle")

@registry.register("stop")
def _c_stop(ctx: Context, *args):
    """Stop playback."""
    _player_helper(ctx, "stop")

@registry.register("mpv")
def _c_mpv(ctx: Context, *args):
    """Play current list with MPV."""
    _player_helper(ctx, "mpv")

@registry.register("vlc")
def _c_vlc(ctx: Context, *args):
    """Play current list with VLC."""
    _player_helper(ctx, "vlc")

@registry.register("send")
def _c_send(ctx: Context, *args):
    """Send list to active DBus player."""
    _player_helper(ctx, "send")

@registry.register("ls", "players")
def cmd_list_players(ctx: Context, *args):
    """List active DBus media players."""
    players = ctx.dbus.get_players()
    ui.print_active_players(players, ctx.dbus.preferred_target)

@registry.register("init")
def cmd_init_player(ctx: Context, *args):
    """Set DBus target player: init <name>."""
    if not args:
        console.print("[red]Usage: init <name>[/]")
        return
    name = args[0]
    ctx.dbus.set_preference(name)
    ctx.config['preferences']['dbus_target'] = name
    save_config(ctx.config)
    console.print(f"[green]âœ” Target set: {name}[/]")

# --- Playlist IO ---

@registry.register("save")
def cmd_save(ctx: Context, *args):
    """Save playlist: save <filename>."""
    if not ctx.play_list:
        console.print("[yellow]âš ï¸ Playlist empty.[/]")
        return
    if not args:
        console.print("[red]Usage: save <name>[/]")
        return
    
    fname = args[0].strip()
    if not fname.endswith(".txt"): fname += ".txt"
    fpath = os.path.join(PLAYLIST_DIR, fname)
    
    try:
        with open(fpath, "w", encoding="utf-8") as f:
            f.write(f"# Saved Playlist: {fname}\n{SEPARATOR}\n")
            for t in ctx.play_list: f.write(f"{t['name']}\n")
        console.print(f"[green]âœ… Saved to: {fname}[/]")
    except Exception as e:
        console.print(f"[red]âŒ Save failed: {e}[/]")

@registry.register("load")
def cmd_load(ctx: Context, *args):
    """Load playlist from file."""
    target_file = None
    if args:
        # Load Direct
        raw = args[0].strip().strip('"')
        if not raw.endswith(".txt"): raw += ".txt"
        if os.path.exists(raw): target_file = raw
        elif os.path.exists(os.path.join(PLAYLIST_DIR, raw)): target_file = os.path.join(PLAYLIST_DIR, raw)
        else:
            console.print(f"[red]âŒ File not found: {raw}[/]")
            return
    else:
        # Load Menu
        txts = glob.glob(os.path.join(PLAYLIST_DIR, "*.txt"))
        if not txts:
            console.print("[red]No playlists found.[/]")
            return
        sel = questionary.select("Select Playlist:", choices=[os.path.basename(f) for f in txts]).ask()
        if not sel: return
        target_file = os.path.join(PLAYLIST_DIR, sel)
    
    # Process
    try:
        with open(target_file, "r", encoding="utf-8") as f:
            content = f.read()
            if SEPARATOR not in content: content = f"{SEPARATOR}\n{content}"
            pl, _ = ctx.aidj.parse_raw_playlist(content, source="User")
            if pl:
                _update_playlist_and_trigger(ctx, pl, None, f"File: {os.path.basename(target_file)}")
            else:
                console.print("[yellow]âš ï¸ No valid tracks found.[/]")
    except Exception as e:
        console.print(f"[red]âŒ Load failed: {e}[/]")

@registry.register("rm", "del", "remove")
def cmd_remove(ctx: Context, *args):
    """Remove song(s): rm <index> (e.g. 'rm 1')."""
    if not ctx.play_list:
        console.print("[yellow]âš ï¸ Playlist is empty.[/]")
        return

    if not args or not args[0].isdigit():
        console.print("[red]Usage: rm <index> (1-based)[/]")
        return

    idx = int(args[0]) - 1
    if 0 <= idx < len(ctx.play_list):
        removed = ctx.play_list.pop(idx)
        ui.print_action_feedback(f"Removed: [bold]{removed['name']}[/]")
        # åªæœ‰å½“åˆ é™¤äº†ä¸œè¥¿ï¼Œæ‰æ‰“å°æ–°çš„åˆ—è¡¨ï¼Œæˆ–è€…ä½ å¯ä»¥é€‰æ‹©åªæ‰“å° feedback
        ui.print_playlist(ctx.play_list, ctx.aidj.metadata, "Updated List")
    else:
        console.print(f"[red]âŒ Index out of range (1-{len(ctx.play_list)}).[/]")

@registry.register("add", "insert")
def cmd_add(ctx: Context, *args):
    """Add song manually: add <song name>."""
    if not args:
        console.print("[red]Usage: add <song name search>[/]")
        return

    query = " ".join(args)
    all_keys = list(ctx.aidj.music_paths.keys())

    # æ¨¡ç³Šæœç´¢åº“
    result = process.extractOne(query, all_keys, scorer=fuzz.token_sort_ratio)

    if result and result[1] > 60:
        name = result[0]
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if any(t['name'] == name for t in ctx.play_list):
            console.print(f"[yellow]âš ï¸ '{name}' is already in the playlist.[/]")
            return

        ctx.play_list.append({"name": name, "path": ctx.aidj.music_paths[name]})
        ui.print_action_feedback(f"Added: [bold]{name}[/]")
        # è‡ªåŠ¨æ»šåŠ¨åˆ°æœ€åä¸€è¡Œæ˜¾ç¤º
        ui.print_playlist(ctx.play_list[-3:], ctx.aidj.metadata, "Added (Showing last 3)")
    else:
        console.print(f"[red]âŒ Song '{query}' not found in library.[/]")

@registry.register("mv", "move")
def cmd_move(ctx: Context, *args):
    """Move song: mv <from> <to> (e.g. 'mv 5 1' moves 5th song to top)."""
    if not ctx.play_list: return

    if len(args) < 2 or not (args[0].isdigit() and args[1].isdigit()):
        console.print("[red]Usage: mv <from_idx> <to_idx>[/]")
        return

    src = int(args[0]) - 1
    dst = int(args[1]) - 1
    max_len = len(ctx.play_list)

    if 0 <= src < max_len and 0 <= dst < max_len:
        item = ctx.play_list.pop(src)
        ctx.play_list.insert(dst, item)
        ui.print_action_feedback(f"Moved '{item['name']}' to #{dst+1}")
        ui.print_playlist(ctx.play_list, ctx.aidj.metadata, "Reordered")
    else:
        console.print("[red]âŒ Index out of range.[/]")

@registry.register("swap", "sw")
def cmd_swap(ctx: Context, *args):
    """Swap two songs: swap <idx1> <idx2>."""
    if len(args) < 2 or not (args[0].isdigit() and args[1].isdigit()):
        console.print("[red]Usage: swap <idx1> <idx2>[/]")
        return

    i1, i2 = int(args[0]) - 1, int(args[1]) - 1
    L = ctx.play_list

    if 0 <= i1 < len(L) and 0 <= i2 < len(L):
        L[i1], L[i2] = L[i2], L[i1]
        ui.print_action_feedback(f"Swapped #{i1+1} and #{i2+1}")
        ui.print_playlist(ctx.play_list, ctx.aidj.metadata, "Swapped")
    else:
        console.print("[red]âŒ Index out of range.[/]")

@registry.register("shuffle", "mix")
def cmd_shuffle(ctx: Context, *args):
    """Shuffle the current playlist."""
    if not ctx.play_list: return
    random.shuffle(ctx.play_list)
    ui.print_action_feedback("Playlist shuffled locally.")
    ui.print_playlist(ctx.play_list, ctx.aidj.metadata, "Shuffled")

@registry.register("reverse", "rev")
def cmd_reverse(ctx: Context, *args):
    """Reverse the playlist order."""
    if not ctx.play_list: return
    ctx.play_list.reverse()
    ui.print_action_feedback("Playlist reversed.")
    ui.print_playlist(ctx.play_list, ctx.aidj.metadata, "Reversed")

@registry.register("dedup", "unique")
def cmd_dedup(ctx: Context, *args):
    """Remove duplicate songs from playlist."""
    if not ctx.play_list: return

    seen = set()
    new_list = []
    for item in ctx.play_list:
        if item['name'] not in seen:
            new_list.append(item)
            seen.add(item['name'])

    removed_count = len(ctx.play_list) - len(new_list)
    ctx.play_list = new_list

    if removed_count > 0:
        ui.print_action_feedback(f"Removed {removed_count} duplicates.")
        ui.print_playlist(ctx.play_list, ctx.aidj.metadata, "Cleaned")
    else:
        console.print("[yellow]âœ¨ No duplicates found.[/]")

@registry.register("clear", "cls")
def cmd_clear(ctx: Context, *args):
    """Clear the playlist."""
    if not ctx.play_list: return
    if questionary.confirm("Clear list?").ask():
        ctx.play_list = []
        ui.print_action_feedback("Playlist cleared.", "yellow")

@registry.register("top")
def cmd_top(ctx: Context, *args):
    """Move a specific song to the top: top <index>."""
    if not args or not args[0].isdigit(): return
    cmd_move(ctx, args[0], "1") # å¤ç”¨ mv å‘½ä»¤é€»è¾‘

@registry.register("view", "list", "pl", "queue")
def cmd_view(ctx: Context, *args):
    """View current playlist: view / list / pl."""
    if not ctx.play_list:
        console.print("[yellow]âš ï¸ Playlist is empty.[/]")
        return
    # å¤ç”¨ ui.py é‡Œçš„æ‰“å°å‡½æ•°
    ui.print_playlist(ctx.play_list, ctx.aidj.metadata, "Current Queue")

def _parse_lrc(lrc_text):
    """è§£æ LRC æ–‡æœ¬ä¸º [(seconds, text), ...]"""
    if not lrc_text: return []
    lines = []
    # åŒ¹é… [mm:ss.xx] æˆ– [mm:ss.xxx]
    pattern = re.compile(r'\[(\d{2}):(\d{2})\.(\d{2,3})\](.*)')
    for line in lrc_text.split('\n'):
        match = pattern.search(line)
        if match:
            m, s, ms_str = int(match.group(1)), int(match.group(2)), match.group(3)
            ms = int(ms_str) * (10 if len(ms_str) == 2 else 1)
            total = m * 60 + s + ms / 1000.0
            text = match.group(4).strip()
            if text: lines.append((total, text))
    lines.sort(key=lambda x: x[0])
    return lines

def _get_lyrics_data(title, artist):
    """è·å–æ­Œè¯æµç¨‹ï¼šæ–‡ä»¶ç¼“å­˜ -> API -> æ–‡ä»¶ä¿å­˜"""
    if not os.path.exists(LYRICS_DIR): os.makedirs(LYRICS_DIR)

    safe_name = re.sub(r'[\\/*?:"<>|]', "", f"{title} - {artist}".strip(" -"))
    fpath = os.path.join(LYRICS_DIR, f"{safe_name}.lrc")

    # 1. è¯»ç¼“å­˜
    if os.path.exists(fpath):
        with open(fpath, 'r', encoding='utf-8') as f:
            return _parse_lrc(f.read())

    # 2. è°ƒ API
    try:
        kw = f"{title} {artist}".strip()
        # æœç´¢
        s_res = requests.get(f"{NCM_BASE_URL}/search", params={"keywords": kw, "limit": 1}, timeout=2).json()

        raw = "[00:00.00] æš‚æ— æ­Œè¯"
        if s_res.get('code') == 200 and s_res['result']['songCount'] > 0:
            sid = s_res['result']['songs'][0]['id']
            # è·å–
            l_res = requests.get(f"{NCM_BASE_URL}/lyric", params={"id": sid}, timeout=2).json()
            if l_res.get('code') == 200:
                raw = l_res.get('lrc', {}).get('lyric', "")
                if not raw: raw = "[00:00.00] çº¯éŸ³ä¹æˆ–æ— æ­Œè¯"

        # 3. å†™ç¼“å­˜
        with open(fpath, 'w', encoding='utf-8') as f:
            f.write(raw)
        return _parse_lrc(raw)
    except Exception:
        return []

# --- Lyrics Command ---
@registry.register("dlyrics", "lrc")
def cmd_dlyrics(ctx: Context, *args):
    """
    Sync lyrics from DBus player with Rich Markdown rendering.
    Usage: dlyrics [player_name] [immersive]
    Example: 'dlyrics immersive', 'dlyrics spotify immersive'
    """
    import bisect
    from rich.markdown import Markdown
    from rich.align import Align # ç¡®ä¿å¼•å…¥ Align

    # --- 0. å‚æ•°è§£æ (å¤„ç† immersive) ---
    args_list = [str(a).lower() for a in args]
    is_immersive = "immersive" in args_list

    # ç§»é™¤ 'immersive' å…³é”®å­—ï¼Œå‰©ä¸‹çš„ä½œä¸ºæ’­æ”¾å™¨åç§°ç­›é€‰
    clean_args = [a for a in args if str(a).lower() != "immersive"]

    # --- é…ç½®åŒºåŸŸ ---
    SYNC_OFFSET = 0

    # --- 1. è¿æ¥ DBus ---
    try:
        bus = dbus.SessionBus()
    except Exception as e:
        console.print(f"[red]âŒ DBus error: {e}[/]")
        return

    # ç¡®å®šç›®æ ‡æ’­æ”¾å™¨
    target = None
    if clean_args:
        target = clean_args[0]
    else:
        current_pref = ctx.config['preferences'].get('dbus_target')
        active_services = [n for n in bus.list_names() if n.startswith("org.mpris.MediaPlayer2")]
        if current_pref and any(current_pref in s for s in active_services):
            target = next(s for s in active_services if current_pref in s)
        elif active_services:
            target = active_services[0]

    if not target:
        console.print("[red]âŒ No active MPRIS player found.[/]")
        return

    try:
        player = bus.get_object(target, "/org/mpris/MediaPlayer2")
        props = dbus.Interface(player, "org.freedesktop.DBus.Properties")
        props.Get("org.mpris.MediaPlayer2.Player", "PlaybackStatus")
    except Exception as e:
        console.print(f"[red]âŒ Failed to connect to {target}: {e}[/]")
        return

    # å¦‚æœä¸æ˜¯æ²‰æµ¸æ¨¡å¼ï¼Œæ‰“å°æç¤ºï¼›æ²‰æµ¸æ¨¡å¼ä¸‹ç›´æ¥è¿›ç•Œé¢
    if not is_immersive:
        console.print(f"[green]ğŸ”— Linked to: {target} (Ctrl+C to quit)[/]")

    # --- 2. ä¸»å¾ªç¯ ---
    last_key = None
    timeline = []
    time_keys = []

    # screen=is_immersive: True æ—¶å¼€å¯å…¨å±ç‹¬å æ¨¡å¼ï¼ˆè‡ªåŠ¨æ¸…ç©ºæ§åˆ¶å°ï¼‰
    # transient=True: é€€å‡ºæ—¶æ¸…é™¤ Live è¾“å‡ºï¼ˆä¿æŒç»ˆç«¯å¹²å‡€ï¼‰
    with Live(console=console, refresh_per_second=10, screen=is_immersive, transient=True) as live:
        try:
            while True:
                try:
                    # è·å–çŠ¶æ€
                    try:
                        meta = props.Get("org.mpris.MediaPlayer2.Player", "Metadata")
                        status = str(props.Get("org.mpris.MediaPlayer2.Player", "PlaybackStatus"))
                    except dbus.exceptions.DBusException:
                        err_panel = Panel("[red]Player disconnected.[/]", title="Connection Lost")
                        # æ²‰æµ¸æ¨¡å¼ä¸‹å±…ä¸­æ˜¾ç¤ºé”™è¯¯
                        if is_immersive: err_panel = Align(err_panel, align="center", vertical="middle")
                        live.update(err_panel)
                        time.sleep(2)
                        break

                    # æå–ä¿¡æ¯
                    title = str(meta.get("xesam:title", "Unknown Title"))
                    artist_list = meta.get("xesam:artist", ["Unknown Artist"])
                    artist = str(artist_list[0]) if (isinstance(artist_list, (list, dbus.Array)) and len(artist_list) > 0) else str(artist_list)
                    curr_key = f"{title}-{artist}"

                    # åˆ‡æ­Œé€»è¾‘
                    if curr_key != last_key:
                        loading_panel = Panel(f"Fetching: {title}...", title="Loading")
                        if is_immersive: loading_panel = Align(loading_panel, align="center", vertical="middle")
                        live.update(loading_panel)

                        last_key = curr_key
                        try:
                            timeline = _get_lyrics_data(title, artist)
                            time_keys = [x[0] for x in timeline]
                        except Exception:
                            timeline = []
                            time_keys = []

                    # æš‚åœçŠ¶æ€
                    if status != "Playing":
                        pause_panel = Panel(
                            Align.center(f"[yellow]â¸ Paused[/]\n\n[bold]{title}[/]\n{artist}"),
                            title="Status", border_style="yellow", padding=(1, 4)
                        )
                        if is_immersive: pause_panel = Align(pause_panel, align="center", vertical="middle")
                        live.update(pause_panel)
                        time.sleep(0.2)
                        continue

                    # åŒæ­¥é€»è¾‘
                    pos = props.Get("org.mpris.MediaPlayer2.Player", "Position") / 1_000_000
                    idx = bisect.bisect_right(time_keys, pos + SYNC_OFFSET) - 1

                    # æ¸²æŸ“å†…å®¹
                    if not timeline:
                        md_content = f"\n\n[dim]No lyrics found for:[/]\n[bold]{title}[/]\n[dim]{artist}[/]"
                        render_obj = Align.center(md_content)
                    else:
                        current_idx = max(0, min(idx, len(timeline) - 1))
                        # æ²‰æµ¸æ¨¡å¼æ˜¾ç¤ºè¡Œæ•°ç¨å¾®å¤šä¸€ç‚¹ç‚¹ï¼Œæ™®é€šæ¨¡å¼ç´§å‡‘ä¸€ç‚¹
                        window_pre = 3 if is_immersive else 2
                        window_post = 5 if is_immersive else 5

                        start_idx = max(0, current_idx - window_pre)
                        end_idx = min(len(timeline), current_idx + window_post)

                        md_str = ""
                        for i in range(start_idx, end_idx):
                            t_sec, text = timeline[i]
                            if not text.strip(): continue

                            if i == current_idx:
                                md_str += f"\n# ğŸµ **{text}** ğŸµ\n"
                            else:
                                md_str += f"{text}\n"

                        render_obj = Align.center(Markdown(md_str, justify="center"))

                    # æ„å»ºé¢æ¿
                    main_panel = Panel(
                        render_obj,
                        title=f"Playing: {title} ({pos:.1f}s)",
                        border_style="green",
                        padding=(1, 2) if not is_immersive else (2, 4), # æ²‰æµ¸æ¨¡å¼ç•™ç™½å¤šä¸€ç‚¹
                        subtitle="[dim]Press Ctrl+C to exit[/]" if is_immersive else None
                    )

                    # å¦‚æœæ˜¯æ²‰æµ¸æ¨¡å¼ï¼Œå°† Panel å‚ç›´å±…ä¸­
                    if is_immersive:
                        final_view = Align(main_panel, align="center", vertical="middle")
                    else:
                        final_view = main_panel

                    live.update(final_view)
                    time.sleep(0.05)

                except KeyboardInterrupt:
                    raise
                except Exception:
                    pass

        except KeyboardInterrupt:
            pass

    # é€€å‡º Live åï¼Œå¦‚æœæ˜¯ immersiveï¼Œå±å¹•ä¼šè‡ªåŠ¨åˆ‡å›æ¥ï¼Œæ— éœ€æ‰‹åŠ¨ clean
    if not is_immersive:
        console.print("[yellow]ğŸ‘‹ Lyrics mode exited.[/]")
```

## File: config.py
```python
import os
import json
from log import *

CONFIG_PATH = "./config.json"
METADATA_PATH = "./music_metadata.json"
PLAYLIST_DIR = "./playlists"
LYRICS_DIR = "./lyrics"
MUSIC_EXTS = ('.mp3', '.flac', '.wav', '.m4a')
NCM_BASE_URL = "http://localhost:3000"
CFG_KEY_MF = "music_folders"

SEPARATOR = "[---SONG_LIST---]"
LANGUAGE = "ç®€ä½“ä¸­æ–‡"

def ensure_playlist_dir():
    if not os.path.exists(PLAYLIST_DIR):
        os.makedirs(PLAYLIST_DIR)
        demo_path = os.path.join(PLAYLIST_DIR, "demo.txt")
        with open(demo_path, "w", encoding="utf-8") as f:
            f.write("# Demo Playlist\nForget\nMerry Christmas Mr. Lawrence")
    return True

def load_config():
    if not os.path.exists(CONFIG_PATH):
        config = {}
    else:
        with open(CONFIG_PATH, "r", encoding="utf-8") as f:
            try:
                config = json.load(f)
            except json.JSONDecodeError:
                log(f"[bold red]âŒ ERROR[/] {CONFIG_PATH} is corrupted!")
                exit(-1)

    if "preferences" not in config:
        config["preferences"] = {}

    pref_defaults = {
        "model": None,
        "verbose": False,
        "saved_trigger": None,
        "dbus_target": None
    }
    for key, val in pref_defaults.items():
        if key not in config["preferences"]:
            config["preferences"][key] = val

    if "ai_settings" not in config:
        config["ai_settings"] = {}

    ai_defaults = {
        "base_url": "https://api.deepseek.com",
        "available_models": ["deepseek-chat", "deepseek-reasoner"],
        "metadata_model": "deepseek-chat",
        "chat_model": "deepseek-chat"
    }

    modified = False
    for key, val in ai_defaults.items():
        if key not in config["ai_settings"]:
            config["ai_settings"][key] = val
            modified = True

    if not config["preferences"]["model"]:
        config["preferences"]["model"] = config["ai_settings"]["chat_model"]
        modified = True

    if modified:
        save_config(config)

    return config

def save_config(config):
    try:
        with open(CONFIG_PATH, "w", encoding="utf-8") as f:
            json.dump(config, f, ensure_ascii=False, indent=4)
    except Exception as e:
        log(f"[red]âŒ Failed to save config: {e}[/]")

def load_cached_metadata():
    if not os.path.exists(METADATA_PATH):
        return {}
    with open(METADATA_PATH, "r", encoding="utf-8") as f:
        try:
            return json.load(f)
        except:
            return {}

# --- Core Logic Functions ---
def scan_music_files(folders):
    music_files = {}
    for folder in folders:
        if not os.path.exists(folder): continue
        for root, _, files in os.walk(folder):
            for file in files:
                if file.lower().endswith(MUSIC_EXTS):
                    file_key = os.path.splitext(file)[0]
                    music_files[file_key] = os.path.join(root, file)
    return music_files
```

## File: dj_core.py
```python
import re
import requests
import threading
from log import *
from tqdm import tqdm
from rich.panel import Panel
from rapidfuzz import process, fuzz
from concurrent.futures import ThreadPoolExecutor

from config import *

def get_song_info(client, song_info, model_name):
    try:
        response = client.chat.completions.create(
            model=model_name,
            messages=[
                {"role": "system", "content": "æå–æ­Œæ›²ä¿¡æ¯JSON: language, emotion, genre, loudness, review"},
                {"role": "user", "content": f"{song_info}"}
            ],
            response_format={'type': 'json_object'},
            stream=False,
            timeout=30.0
        )
        return response.choices[0].message.content
    except KeyboardInterrupt: raise
    except Exception as e:
        return None

def sync_metadata(client, targets, metadata, model_name):
    if not targets: return metadata
    log(f"[cyan]ğŸš€ Syncing {len(targets)} new songs using {model_name}... (Ctrl+C to skip)[/]")
    pbar = tqdm(targets.items(), unit="song")
    try:
        for name, path in pbar:
            pbar.set_postfix_str(f"{name[:10]}...")
            try:
                res = requests.get(f"{NCM_BASE_URL}/search?keywords=\"{name}\"&limit=1", timeout=5).json()
                if res.get('code')!=200 or res['result']['songCount']==0: continue
                sid = res['result']['songs'][0]['id']
                l_res = requests.get(f"{NCM_BASE_URL}/lyric", params={"id": sid}, timeout=5).json()
                raw_lyric = l_res.get('lrc', {}).get('lyric', "æš‚æ— æ­Œè¯")

                info = {"title": name, "lyrics": raw_lyric[:500]}
                resp = get_song_info(client, info, model_name)

                if resp:
                    metadata[name] = json.loads(resp)
                    with open(METADATA_PATH, "w") as f: json.dump(metadata, f, ensure_ascii=False, indent=4)
            except KeyboardInterrupt: raise
            except: continue
    except KeyboardInterrupt:
        log("\n[yellow]âš ï¸ Sync skipped.[/]")
    return metadata

class DJSession:
    def __init__(self, client, metadata, music_paths, config , wait_inject_prepare , wait_inject_main , wait_inject_after):
        self.client = client
        self.metadata = metadata
        self.music_paths = music_paths
        self.config = config
        self.chat_history = []
        self.turn_count = 0
        self.played_songs = set()
        self.wait_injects = [wait_inject_prepare,wait_inject_main,wait_inject_after]

    def refresh(self, clear_history=False):
        self.played_songs.clear()
        if clear_history:
            self.chat_history = []
            self.turn_count = 0
            log("[yellow]ğŸ§¹ Cleared History[/]")
        else:
            log("[yellow]ğŸ§¹ Cleared Played Songs[/]")

    def _format_library(self):
        lines = []
        available = set(self.metadata.keys()) & set(self.music_paths.keys())
        for name in list(available):
            info = self.metadata[name]
            if isinstance(info, dict):
                lines.append(f"- {name}: {info.get('genre','Pop')}, {info.get('emotion','Neutral')}")
        return "\n".join(lines)

    def parse_raw_playlist(self, raw_text, source="AI"):
        playlist_names = []
        intro_text = ""
        is_verbose = self.config['preferences']['verbose']

        if SEPARATOR in raw_text:
            parts = raw_text.split(SEPARATOR)
            intro_text = parts[0].strip()
            raw_list_block = parts[1]
            if is_verbose: log(f"[dim]âœ… Separator found. Parsing list...[/]")
        else:
            if is_verbose and source == "AI":
                log(f"[dim]â„¹ï¸ No separator found. Treating as pure conversation.[/]")
            intro_text = raw_text.strip()
            raw_list_block = ""

        lines = [l.strip() for l in raw_list_block.split('\n') if l.strip()]
        valid_keys = list(set(self.metadata.keys()) & set(self.music_paths.keys()))

        for line in lines:
            if line.startswith("#"): continue
            clean = line.replace('"', '').replace("'", "").strip()
            if len(clean) < 2: continue

            match = None
            result = process.extractOne(
                clean, valid_keys, scorer=fuzz.token_sort_ratio, score_cutoff=80
            )

            if result:
                match_name = result[0]
                if is_verbose: log(f"[dim]ğŸ” Match: {clean} -> [green]{match_name}[/][/]")
                match = match_name

            if match:
                playlist_names.append(match)
            else:
                if is_verbose and SEPARATOR in raw_text:
                     log(f"[dim]âŒ Ignored line: {clean}[/]")

        playlist_names = list(dict.fromkeys(playlist_names))
        playlist = []
        for name in playlist_names:
            if source == "AI": self.played_songs.add(name)
            playlist.append({"name": name, "path": self.music_paths[name]})

        return playlist, intro_text

    def next_step(self, user_request):
        # --- 1. é…ç½®ä¸çŠ¶æ€æ›´æ–° ---
        self.turn_count += 1
        model = self.config['preferences']['model']
        is_verbose = self.config['preferences']['verbose']

        if is_verbose: log(f"[dim]ğŸ¤– Thinking with {model}...[/]")

        # --- 2. æ„å»ºç³»ç»ŸæŒ‡ä»¤ (System Prompt - Optimized) ---
        # ä½¿ç”¨â€œåè®®æ¨¡å¼â€å‘Šè¯‰AIï¼Œå®ƒæ­£åœ¨é€šè¿‡ä¸€ä¸ªä¸¥æ ¼çš„ç®¡é“ä¼ è¾“æ•°æ®
        base_prompt = f"""
### ROLE DEFINITION
You are a **charismatic, knowledgeable, and expressive AI Radio Host**.
Your goal is not just to list songs, but to **curate an experience**.
-   **Personality:** Passionate, poetic, slightly "hyped" or "deep" (depending on the mood), and vibe-focused.
-   **Rule:** BE EXPRESSIVE. Do NOT give short, robotic responses like "Here is your list."
-   **Method:** Weave a narrative. Talk about the *texture* of the sound, the *emotion* of the artists, and *why* these songs fit the moment. Create a "scene" for the listener.

### DATA SOURCE (CRITICAL)
You are provided with a **Music Library**.
-   **RESTRICTION:** You can ONLY select songs that exist EXACTLY in the provided Library.
-   **PROHIBITION:** Do NOT hallucinate songs. Do NOT translate song titles. Do NOT fix typos in the library keys. Use the keys exactly as they appear.
-   If no songs in the library fit the mood, just chat (expressively!) and DO NOT output the separator.

### OUTPUT PROTOCOL
Your output is parsed by a Python script. You must strictly follow this structure:

[Part 1: The Intro]
(Content: A rich, paragraph-length DJ commentary. Use Markdown bolding for emphasis and emojis to set the mood. Talk about the genre, the instruments, or the feeling.)

{SEPARATOR}

[Part 2: The Payload]
(Content: Exact song keys from the Library. Hidden from the user, executed by system.)
(Format: One key per line. NO numbering. NO markdown bullets. NO extra text.)

### EXAMPLE INTERACTION
**Library:** ['Bohemian Rhapsody', 'Imagine', 'Billie Jean']
**User:** "Play something sad."
**Your Output:**
Oh, I feel that heavy energy in the air tonight. ğŸŒ§ï¸ Sometimes we just need to let the tears flow to heal, right? I've pulled a track that is the definition of raw soulâ€”it's just a piano and a voice, stripping away all the pretense to touch the core of humanity. Let's slow down the world for a moment and just *listen*. ğŸ¹ğŸ’”
{SEPARATOR}
Imagine
"""

        # --- 3. æ³¨å…¥ä¸Šä¸‹æ–‡ (Context Injection) ---
        # é€‚æ—¶æ³¨å…¥ Libraryï¼Œé˜²æ­¢ä¸Šä¸‹æ–‡è¿‡é•¿ï¼Œä½†ä¿è¯ AI éšæ—¶èƒ½çœ‹åˆ°æ¸…å•
        if self.turn_count == 1 or self.turn_count % 5 == 0:
            # å¼ºåŒ– Library çš„è¾¹ç•Œæ„Ÿ
            library_str = self._format_library()
            system_content = f"{base_prompt}\n\n### CURRENT MUSIC LIBRARY (Exact Keys Only):\n{library_str}"

            self.chat_history.append({"role": "system", "content": system_content})
            if is_verbose: log("[dim]ğŸ”„ Context refreshed with strict library constraints.[/]")

        # --- 4. æ„å»ºç”¨æˆ·è¯·æ±‚ (User Message) ---
        # åœ¨è¿™é‡Œå†æ¬¡å¼ºè°ƒâ€œå°é—­é›†åˆâ€æ¦‚å¿µ
        forbidden_list = ', '.join(list(self.played_songs)) if self.played_songs else "None"

        full_req = (
            f"User Request: \"{user_request}\"\n"
            f"Constraint: Don't repeat these songs: [{forbidden_list}]\n"
            f"Language Rule: Detect the language used in the 'User Request'. The [Intro] section MUST be written in that EXACT SAME language. (e.g. If user asks in Chinese, reply in Chinese).\n"
            f"Instruction: Check the Library provided in System context. "
            f"If matches found, output Intro + {SEPARATOR} + SongKeys. "
            f"If no matches, just Intro."
        )
        self.chat_history.append({"role": "user", "content": full_req})

        # --- 5. ğŸ® äº¤äº’å¼ç­‰å¾…æ¨¡å¼ (Streaming + Game) ---

        stop_event = threading.Event()
        ai_status = {'count': 0}  # å…±äº«çŠ¶æ€ï¼šå­—æ•°ç»Ÿè®¡

        def ask_ai_streaming():
            full_content = ""
            try:
                # å¼€å¯æµå¼ stream=True
                stream = self.client.chat.completions.create(
                    model=model,
                    messages=self.chat_history,
                    timeout=180.0,
                    stream=True
                )

                for chunk in stream:
                    # [ä¿®å¤ç‚¹ 1] å¿…é¡»å…ˆæ£€æŸ¥ choices åˆ—è¡¨æ˜¯å¦éç©º
                    # é˜²æ­¢éƒ¨åˆ†å¿ƒè·³åŒ…æˆ–ç»“æŸåŒ…ä¸ºç©ºå¯¼è‡´ IndexError
                    if not chunk.choices:
                        continue

                    # [ä¿®å¤ç‚¹ 2] è·å– delta
                    delta = chunk.choices[0].delta

                    # [ä¿®å¤ç‚¹ 3] ç¡®ä¿ content å­˜åœ¨ä¸”ä¸ä¸º None
                    if getattr(delta, 'content', None):
                        content = delta.content
                        full_content += content

                        # æ›´æ–°å…±äº«è®¡æ•°å™¨ï¼Œæ¸¸æˆçº¿ç¨‹ä¼šè¯»å–è¿™ä¸ªå€¼
                        ai_status['count'] = len(full_content)

                return full_content

            except Exception as e:
                return e
            finally:
                # æ— è®ºæˆåŠŸå¤±è´¥ï¼Œé€šçŸ¥æ¸¸æˆåœæ­¢
                stop_event.set()

        # å‡†å¤‡ç»ˆç«¯ç¯å¢ƒ
        if self.wait_injects[0] is not None:
            self.wait_injects[0]()
        result = None

        with ThreadPoolExecutor(max_workers=1) as executor:
            future = executor.submit(ask_ai_streaming)
            try:
                # ä¼ å…¥ stop_event å’Œ ai_status
                if self.wait_injects[1] is not None:
                    self.wait_injects[1](stop_event, ai_status)

            except KeyboardInterrupt:
                log("\n[dim]âš ï¸ Interrupted.[/]")
                stop_event.set()
                return [], ""
            finally:
                if self.wait_injects[2] is not None:
                    self.wait_injects[2]()

            result = future.result()

        # --- 6. ç»“æœå¤„ç† ---
        if isinstance(result, Exception):
            err_msg = str(result)
            if "timeout" in err_msg.lower():
                log(f"[red]â³ AI Request Timed Out (180s)[/]")
            else:
                log(f"[red]âŒ API Error:[/]{err_msg}")
            return [], ""

        # æµå¼è¿”å›çš„å·²ç»æ˜¯å®Œæ•´å­—ç¬¦ä¸²äº†
        raw = result

        # æ¸…æ´— <think> æ ‡ç­¾ (é’ˆå¯¹ DeepSeek R1 ç­‰æ¨ç†æ¨¡å‹)
        clean_content = re.sub(r'<think>.*?</think>', '', raw, flags=re.DOTALL).strip()
        if not clean_content: clean_content = raw

        if is_verbose:
            log(Panel(raw, title="Raw AI Output (With Thoughts)", border_style="dim"))

        # å­˜å…¥å†å²
        self.chat_history.append({"role": "assistant", "content": clean_content})

        # è§£æå¹¶è¿”å›
        return self.parse_raw_playlist(clean_content, source="AI")
```

## File: log.py
```python
import sys

def _default_log_fn(data, *args, **kwargs):
    """é»˜è®¤æ—¥å¿—å‡½æ•°ï¼šä»€ä¹ˆä¹Ÿä¸åš"""
    pass

# æ ¸å¿ƒå­˜å‚¨ï¼šä½¿ç”¨æ¨¡å—å±æ€§ç¡®ä¿å…¨å±€å…±äº«
_module = sys.modules[__name__]

# åˆå§‹åŒ–æ—¥å¿—å‡½æ•°
_module._log_fn = _default_log_fn

def log(data, *args, **kwargs):
    """
    æ—¥å¿—è¾“å‡ºå‡½æ•° - å®Œå…¨å…¼å®¹åŸå§‹API
    
    æ”¯æŒï¼š
    - log("æ¶ˆæ¯")
    - log("æ¶ˆæ¯", style="red")  # å¦‚æœè¾“å‡ºå‡½æ•°æ”¯æŒ kwargs
    - log(f"[bold]æ¶ˆæ¯[/]")
    """
    try:
        # å¦‚æœdataæ˜¯å­—ç¬¦ä¸²ä¸”æœ‰argsï¼Œæ ¼å¼åŒ–
        if args and isinstance(data, str):
            try:
                data = data.format(*args)
            except:
                pass  # å¦‚æœæ ¼å¼åŒ–å¤±è´¥ï¼Œä¿æŒåŸæ ·
        
        # è°ƒç”¨å½“å‰æ—¥å¿—å‡½æ•°
        _module._log_fn(data, *args, **kwargs)
    except Exception:
        # å¦‚æœæ—¥å¿—å‡½æ•°å‡ºé”™ï¼Œé™é»˜å¤±è´¥
        pass

def set_log_fn(fn):
    """
    è®¾ç½®æ—¥å¿—å‡½æ•° - å®Œå…¨å…¼å®¹åŸå§‹API
    
    å‚æ•°:
        fn: è¾“å‡ºå‡½æ•°ï¼Œå¦‚ console.printã€print ç­‰
    """
    if not callable(fn):
        raise TypeError("æ—¥å¿—å‡½æ•°å¿…é¡»æ˜¯å¯è°ƒç”¨çš„")
    
    # ä¿å­˜åˆ°æ¨¡å—å±æ€§ï¼ˆå…¨å±€å…±äº«ï¼‰
    _module._log_fn = fn
    
    # å¯é€‰ï¼šæµ‹è¯•è¾“å‡º
    try:
        fn("[dim]âœ… æ—¥å¿—ç³»ç»Ÿå·²åˆå§‹åŒ–[/]")
    except:
        pass
```

## File: lyrics_sync.py
```python
import os
import json
import time
import re
import random
import requests
import glob
from pathlib import Path

# å°è¯•å¼•å…¥ Richï¼Œå¦‚æœç¯å¢ƒæ²¡è£…åˆ™æŠ¥é”™æç¤º
try:
    from rich.console import Console
    from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeRemainingColumn
    from rich.panel import Panel
except ImportError:
    print("è¯·å…ˆå®‰è£… rich: pip install rich")
    exit(1)

# å¼•å…¥é¡¹ç›®é…ç½®
try:
    from config import LYRICS_DIR, NCM_BASE_URL, CONFIG_FILE
except ImportError:
    #ä»¥æ­¤ä½œä¸º fallbackï¼Œé˜²æ­¢å•ç‹¬è¿è¡Œæ‰¾ä¸åˆ° config.py
    LYRICS_DIR = "./lyrics"
    NCM_BASE_URL = "http://localhost:3000" # å‡è®¾ä½ çš„ NCM API åœ°å€
    CONFIG_FILE = "./config.json"

console = Console()

# æ”¯æŒçš„éŸ³é¢‘æ ¼å¼
AUDIO_EXTENSIONS = {'.mp3', '.flac', '.wav', '.m4a', '.ogg', '.opus'}

def load_library_paths():
    """ä» config.json è¯»å–éŸ³ä¹åº“è·¯å¾„ï¼Œå¦‚æœæ²¡é…ç½®åˆ™é»˜è®¤ä¸ºå½“å‰ç›®å½•"""
    paths = ["."]
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                conf = json.load(f)
                # å‡è®¾é…ç½®é‡Œæœ‰ä¸ª library_paths æˆ–è€… music_dirsï¼Œå¦‚æœæ²¡æœ‰å°±æ‰«æå½“å‰æ–‡ä»¶å¤¹
                # ä½ å¯ä»¥æ ¹æ®ä½ å®é™… config.json çš„ç»“æ„ä¿®æ”¹è¿™é‡Œ
                if 'music_folders' in conf:
                    paths = conf['music_folders']
                elif 'music_dirs' in conf:
                    paths = conf['music_dirs']
        except Exception as e:
            console.print(f"[yellow]âš ï¸ è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥ï¼Œå°†æ‰«æå½“å‰ç›®å½•: {e}[/]")
    return paths

def scan_music_files(paths):
    """æ‰«ææ‰€æœ‰è·¯å¾„ä¸‹çš„éŸ³é¢‘æ–‡ä»¶"""
    music_files = []
    for p in paths:
        if not os.path.exists(p):
            continue
        # é€’å½’æ‰«æ
        for root, dirs, files in os.walk(p):
            for file in files:
                if os.path.splitext(file)[1].lower() in AUDIO_EXTENSIONS:
                    full_path = os.path.join(root, file)
                    music_files.append(full_path)
    return music_files

def clean_filename(filename):
    """æ¸…æ´—æ–‡ä»¶åä»¥ä¾¿æœç´¢ (ç§»é™¤æ‰©å±•åã€æ‹¬å·å†…å®¹ç­‰)"""
    # ç§»é™¤æ‰©å±•å
    name = os.path.splitext(filename)[0]
    # ç§»é™¤ (Live), [HQ] ç­‰æ‹¬å·å†…å®¹
    name = re.sub(r'[\(\[].*?[\)\]]', '', name)
    # ç§»é™¤ feat. xxx
    name = re.sub(r'(?i)feat\..*', '', name)
    # å°†ä¸‹åˆ’çº¿å’Œè¿å­—ç¬¦æ¢æˆç©ºæ ¼
    name = name.replace('_', ' ').replace('-', ' ')
    # ç§»é™¤å¤šä½™ç©ºæ ¼
    return " ".join(name.split())

def fetch_lyric_ncm(keyword):
    """è°ƒç”¨ NCM API ä¸‹è½½æ­Œè¯"""
    try:
        # 1. æœç´¢æ­Œæ›² ID
        search_url = f"{NCM_BASE_URL}/search"
        params = {"keywords": keyword, "limit": 1}
        resp = requests.get(search_url, params=params, timeout=5)
        data = resp.json()
        
        if data.get('code') != 200 or data['result']['songCount'] == 0:
            return None
        
        song_id = data['result']['songs'][0]['id']
        
        # 2. è·å–æ­Œè¯
        lrc_url = f"{NCM_BASE_URL}/lyric"
        resp = requests.get(lrc_url, params={"id": song_id}, timeout=5)
        lrc_data = resp.json()
        
        if lrc_data.get('code') == 200:
            lyric = lrc_data.get('lrc', {}).get('lyric')
            return lyric
    except Exception:
        return None
    return None

def main():
    console.clear()
    console.print(Panel.fit("[bold cyan]ğŸµ Lyric Sync Utility[/]", border_style="cyan"))

    # 1. å‡†å¤‡ç›®å½•
    if not os.path.exists(LYRICS_DIR):
        os.makedirs(LYRICS_DIR)
        console.print(f"[green]ğŸ“‚ Created lyrics directory: {LYRICS_DIR}[/]")

    # 2. æ‰«ææ–‡ä»¶
    paths = load_library_paths()
    with console.status(f"[bold green]Scanning music files in: {paths}...[/]"):
        files = scan_music_files(paths)
    
    if not files:
        console.print("[red]âŒ No music files found![/]")
        return

    console.print(f"[green]âœ… Found {len(files)} audio files.[/]")
    
    # 3. å¼€å§‹åŒæ­¥
    skipped = 0
    success = 0
    failed = 0
    
    # ä½¿ç”¨ Rich è¿›åº¦æ¡
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
        TimeRemainingColumn(),
        console=console
    ) as progress:
        
        task = progress.add_task("[cyan]Syncing lyrics...", total=len(files))
        
        for file_path in files:
            file_name = os.path.basename(file_path)
            # ç”Ÿæˆå®‰å…¨çš„æ­Œè¯æ–‡ä»¶å (ä¸æ’­æ”¾å™¨é€»è¾‘ä¸€è‡´)
            # è¿™é‡Œçš„é€»è¾‘å¿…é¡»å’Œä½ æ’­æ”¾å™¨é‡Œ _get_lyrics_data çš„ safe_name é€»è¾‘å°½é‡ä¸€è‡´
            # å¦‚æœæ’­æ”¾å™¨æ˜¯ç”¨ "Title - Artist" æœçš„ï¼Œè¿™é‡Œæœ€å¥½ä¹Ÿæ˜¯ã€‚
            # ä½†è¿™é‡Œæˆ‘ä»¬åªæœ‰æ–‡ä»¶åï¼Œé€šå¸¸æ–‡ä»¶åå°±æ˜¯ "Title - Artist.mp3"
            
            clean_name_for_save = os.path.splitext(file_name)[0]
            # ç®€å•æ¸…æ´—æ–‡ä»¶åç”¨äºä¿å­˜ (å»é™¤ç³»ç»Ÿéæ³•å­—ç¬¦)
            clean_name_for_save = re.sub(r'[\\/*?:"<>|]', "", clean_name_for_save)
            lrc_path = os.path.join(LYRICS_DIR, f"{clean_name_for_save}.lrc")
            
            progress.update(task, description=f"[cyan]Processing: {file_name}")

            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            if os.path.exists(lrc_path):
                # console.print(f"[dim]â­ï¸  Skipped (Exists): {file_name}[/dim]")
                skipped += 1
                progress.advance(task)
                continue
            
            # æ„é€ æœç´¢å…³é”®è¯
            search_kw = clean_filename(file_name)
            
            # ä¸‹è½½
            lyric_content = fetch_lyric_ncm(search_kw)
            
            if lyric_content:
                try:
                    with open(lrc_path, 'w', encoding='utf-8') as f:
                        f.write(lyric_content)
                    # console.print(f"[green]â¬‡ï¸  Downloaded: {file_name}[/]")
                    success += 1
                except Exception as e:
                    console.print(f"[red]âŒ Write Error {file_name}: {e}[/]")
                    failed += 1
            else:
                # console.print(f"[yellow]âš ï¸  Not Found: {file_name}[/]")
                failed += 1
            
            progress.advance(task)
            
            # éšæœºå»¶è¿Ÿé˜²æ­¢å°ç¦ (0.1s - 0.5s)
            # time.sleep(random.uniform(0.1, 0.5))

    # 4. æ€»ç»“
    console.print("\n[bold]ğŸ‰ Sync Completed![/]")
    console.print(f"[dim]Total Files: {len(files)}[/]")
    console.print(f"[green]Existing/Skipped: {skipped}[/]")
    console.print(f"[blue]Downloaded New: {success}[/]")
    console.print(f"[red]Failed/Not Found: {failed}[/]")

if __name__ == "__main__":
    main()
```

## File: main.py
```python
import sys
import openai
import termios
import questionary
# [æ–°å¢] å¼•å…¥ Completer æ¥å£
from prompt_toolkit.completion import WordCompleter, Completer 
from prompt_toolkit.history import FileHistory
from questionary import Style

# å¼•å…¥æ¨¡å—
from log import set_log_fn
from config import load_config, CFG_KEY_MF, ensure_playlist_dir
from dj_core import DJSession, scan_music_files, load_cached_metadata, sync_metadata
from wait_games import run_waiting_game
from player import DBusManager
import ui

from command_handler import Context, registry, console
import commands 

# --- Terminal Injection Helpers ---
fd = sys.stdin.fileno()
old_settings = None

def inject_pre():
    global old_settings
    old_settings = termios.tcgetattr(fd)

def inject_aft():
    termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    try: termios.tcflush(sys.stdin, termios.TCIFLUSH)
    except: pass

# --- [æ–°å¢] è‡ªå®šä¹‰è¡¥å…¨å™¨é€»è¾‘ ---
class CommandOnlyCompleter(Completer):
    """
    æ™ºèƒ½è¡¥å…¨å™¨ï¼šåªæœ‰åœ¨è¾“å…¥ç¬¬ä¸€ä¸ªå•è¯ï¼ˆå‘½ä»¤ï¼‰æ—¶æ‰è§¦å‘è¡¥å…¨ã€‚
    ä¸€æ—¦è¾“å…¥äº†ç©ºæ ¼ï¼ˆè¿›å…¥å‚æ•°éƒ¨åˆ†ï¼‰ï¼Œå°±åœæ­¢è¡¥å…¨ã€‚
    """
    def __init__(self, base_completer):
        self.base_completer = base_completer

    def get_completions(self, document, complete_event):
        # è·å–å…‰æ ‡å‰çš„æ–‡æœ¬ï¼Œå¹¶å»æ‰å¼€å¤´çš„ç©ºæ ¼
        text = document.text_before_cursor.lstrip()
        
        # å¦‚æœå»æ‰å¼€å¤´ç©ºæ ¼åï¼Œæ–‡æœ¬é‡Œä¾ç„¶åŒ…å«ç©ºæ ¼ï¼Œè¯´æ˜ç”¨æˆ·å·²ç»æ‰“å®Œäº†å‘½ä»¤ï¼Œæ­£åœ¨æ‰“å‚æ•°
        # æ­¤æ—¶ç›´æ¥è¿”å›ï¼Œä¸æä¾›è¡¥å…¨
        if " " in text:
            return

        # å¦åˆ™ï¼Œè°ƒç”¨åŸºç¡€çš„ WordCompleter è¿›è¡Œè¡¥å…¨
        yield from self.base_completer.get_completions(document, complete_event)

# --- Main ---

def main():
    set_log_fn(console.print)
    
    # 1. åˆå§‹åŒ–é…ç½®
    config = load_config()
    secrets = config.get("secrets", {})
    ai_settings = config.get("ai_settings", {})
    
    api_key = secrets.get("api_key") or secrets.get("deepseek", "")
    base_url = ai_settings.get("base_url", "https://api.deepseek.com")
    
    client = openai.OpenAI(api_key=api_key, base_url=base_url)
    dbus_manager = DBusManager(preferred_target=config['preferences'].get('dbus_target'))
    
    # 2. å‡†å¤‡æ•°æ®
    musics = scan_music_files(config.get(CFG_KEY_MF, []))
    metadata = load_cached_metadata()
    
    # 3. å…ƒæ•°æ®åŒæ­¥
    missing = {k:v for k,v in musics.items() if k not in metadata}
    if missing:
        model = ai_settings.get("metadata_model", "deepseek-chat")
        metadata = sync_metadata(client, missing, metadata, model)
    
    ensure_playlist_dir()
    
    # 4. åˆ›å»º Session
    aidj = DJSession(client, metadata, musics, config, inject_pre, run_waiting_game, inject_aft)
    
    # 5. æ„å»º Context
    ctx = Context(aidj, dbus_manager, config)
    
    # 6. UI Banner
    ui.print_banner(base_url, config['preferences']['model'])
    
    # 7. å‡†å¤‡ Prompt å·¥å…·
    history = FileHistory(".dj_history")
    
    # [ä¿®æ”¹] å…ˆåˆ›å»ºåŸºç¡€çš„ WordCompleterï¼Œå†ç”¨æˆ‘ä»¬çš„ CommandOnlyCompleter åŒ…è£¹å®ƒ
    base_completer = WordCompleter(registry.get_command_list(), ignore_case=True)
    smart_completer = CommandOnlyCompleter(base_completer)
    
    style = Style([
        ('qmark', 'fg:#673ab7 bold'),
        ('question', 'bold'),
        ('answer', 'fg:#f44336 bold'),
    ])

    # 8. ä¸»å¾ªç¯
    while True:
        try:
            curr_trig = config['preferences'].get('saved_trigger')
            prefix = f"[âš¡ {curr_trig}] " if curr_trig else ""
            
            user_input = questionary.text(
                f"{prefix}AIDJ >",
                qmark="ğŸ¤",
                style=style,
                history=history,
                completer=smart_completer # [ä¿®æ”¹] ä½¿ç”¨æ™ºèƒ½è¡¥å…¨å™¨
            ).ask()
            
            if user_input is None: 
                console.print("[bold red]ğŸ‘‹ Bye![/]")
                break
                
            registry.dispatch(user_input, ctx)
            
        except KeyboardInterrupt:
            console.print("\n[yellow]Cancelled.[/]")
        except SystemExit:
            break
        except Exception as e:
            console.print(f"[red]CRITICAL ERROR: {e}[/]")
            # import traceback; traceback.print_exc()

if __name__ == "__main__":
    main()
```

## File: player.py
```python
import re
import subprocess
import time
import shutil
from log import log

class DBusManager:
    def __init__(self, preferred_target=None):
        self.preferred_target = preferred_target
        self.available = shutil.which("dbus-send") is not None 

    def set_preference(self, target_name):
        self.preferred_target = target_name

    def _run_cmd(self, args):
        try:
            result = subprocess.run(
                args, capture_output=True, text=True, check=True
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError:
            return None

    def get_players(self):
        if not self.available: return []
        cmd = ["dbus-send", "--session", "--dest=org.freedesktop.DBus", "--type=method_call", "--print-reply", "/org/freedesktop/DBus", "org.freedesktop.DBus.ListNames"]
        output = self._run_cmd(cmd)
        if not output: return []
        players = []
        for line in output.split("\n"):
            match = re.search(r'"(org\.mpris\.MediaPlayer2\.[^"]+)"', line)
            if match: players.append(match.group(1))
        return players

    def get_active_player(self):
        players = self.get_players()
        if not players: return None, "No Active Players"
        target = None
        if self.preferred_target:
            target = next((p for p in players if self.preferred_target.lower() in p.lower()), None)
        if not target:
            target = next((p for p in players if "mpv" in p), None)
        if not target:
            target = players[0]
        return target, target

    def send_files(self, file_paths):
        dest, name = self.get_active_player()
        if not dest: return False, name
        count = 0
        for path in file_paths:
            uri = f"file://{path}"
            cmd = ["dbus-send", "--session", "--type=method_call", f"--dest={dest}", "/org/mpris/MediaPlayer2", "org.mpris.MediaPlayer2.Player.OpenUri", f"string:{uri}"]
            if self._run_cmd(cmd) is not None:
                count += 1
                time.sleep(0.05)
        return True, f"Sent {count} tracks to {name}"

    def control(self, command):
        dest, name = self.get_active_player()
        if not dest: return False, name
        method_map = {"next": "Next", "prev": "Previous", "play": "Play", "pause": "Pause", "toggle": "PlayPause", "stop": "Stop"}
        if command not in method_map: return False, "Unknown Command"
        cmd = ["dbus-send", "--session", "--type=method_call", f"--dest={dest}", "/org/mpris/MediaPlayer2", f"org.mpris.MediaPlayer2.Player.{method_map[command]}"]
        if self._run_cmd(cmd) is not None:
            return True, f"Executed {command} on {name}"
        return False, "Command Failed"

def execute_player_command(command, playlist, dbus_manager):
    if command in ["next", "prev", "play", "pause", "toggle", "stop"]:
        ok, msg = dbus_manager.control(command)
        color = "green" if ok else "red"
        log(f"[{color}]ğŸ“¡ DBus: {msg}[/]")
        return

    if not playlist and command in ["mpv", "vlc", "send"]:
        log("[red]âŒ No playlist cached! Use 'p <text>' first.[/]")
        return

    paths = [item['path'] for item in playlist] if playlist else []

    if command == "send":
        if not dbus_manager.available:
            log("[red]âŒ 'dbus-send' missing[/]")
            return
        ok, msg = dbus_manager.send_files(paths)
        color = "green" if ok else "red"
        log(f"[{color}]ğŸ“¡ DBus: {msg}[/]")
    elif command == "mpv":
        log(f"[green]ğŸ”Š MPV ({len(playlist)} trks)[/]")
        subprocess.Popen(['mpv', '--force-window', '--geometry=600x600'] + paths, stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            stdin=subprocess.DEVNULL,
            start_new_session=True)
    elif command == "vlc":
        log(f"[green]ğŸŸ  VLC ({len(playlist)} trks)[/]")
        subprocess.Popen(['vlc', '--one-instance', '--playlist-enqueue'] + paths, stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            stdin=subprocess.DEVNULL,
            start_new_session=True)
```

## File: ui.py
```python
import json
from rich.table import Table
from rich.panel import Panel
from rich.markdown import Markdown
from command_handler import console
import re

def print_banner(base_url, model):
    console.print(Panel.fit(
        f"[bold cyan]          AI DJ SYSTEM v4.0 (Refactored)        [/]\n"
        f"[dim]Endpoint: {base_url}[/]\n"
        f"[dim]Model: {model}[/]",
        title="âœ¨ System Ready âœ¨", border_style="magenta"
    ))

def print_dj_intro(intro_text):
    if not intro_text: return
    # æ¸…æ´— <think> æ ‡ç­¾
    clean_intro = re.sub(r'<think>.*?</think>', '', intro_text, flags=re.DOTALL).strip()
    if clean_intro:
        md_content = Markdown(clean_intro)
        console.print(Panel(
            md_content,
            title="ğŸ’¬ DJ Says",
            border_style="bold magenta",
            padding=(1, 2)
        ))

def print_playlist(playlist, metadata, title_suffix="List"):
    t = Table(show_header=True, title=f"Playlist ({len(playlist)}) - {title_suffix}", show_lines=True)
    t.add_column("Track", style="bold green", no_wrap=True)
    t.add_column("Language", style="cyan")
    t.add_column("Genre", style="magenta")
    t.add_column("Emotion", style="yellow")
    t.add_column("Loudness", style="dim")

    for item in playlist:
        name = item['name']
        info = metadata.get(name, {})
        
        def safe_fmt(val):
            if val is None: return "-"
            if isinstance(val, list): return ", ".join(str(x) for x in val)
            return str(val)
            
        t.add_row(
            name, 
            safe_fmt(info.get('language')), 
            safe_fmt(info.get('genre')), 
            safe_fmt(info.get('emotion')), 
            safe_fmt(info.get('loudness'))
        )
    console.print(t)

def print_status(config, ai_settings, playlist_len):
    t = Table(title="âš™ï¸ System Status")
    t.add_column("Setting", style="cyan")
    t.add_column("Value", style="yellow")
    t.add_row("API Endpoint", ai_settings.get("base_url"))
    t.add_row("Current Model", config['preferences']['model'])
    t.add_row("Metadata Model", ai_settings.get("metadata_model", "N/A"))
    t.add_row("Verbose Mode", str(config['preferences']['verbose']))
    t.add_row("Auto Trigger", str(config['preferences']['saved_trigger'] or "OFF"))
    t.add_row("DBus Target", str(config['preferences']['dbus_target'] or "Auto"))
    t.add_row("Playlist Cache", f"{playlist_len} tracks")
    console.print(t)

def print_metadata(name, data):
    t = Table(title=f"â„¹ï¸ Metadata: [bold green]{name}[/]", border_style="blue")
    t.add_column("Field", style="bold cyan", justify="right")
    t.add_column("Value", style="white", overflow="fold")
    if isinstance(data, dict):
        for k in sorted(data.keys()):
            v = data[k]
            if k == "lyrics":
                val_str = str(v)[:100].replace("\n", " ") + "... (truncated)"
            elif isinstance(v, (list, dict)):
                val_str = json.dumps(v, ensure_ascii=False)
            else:
                val_str = str(v)
            t.add_row(k, val_str)
    else:
        t.add_row("Raw Data", str(data))
    console.print(t)

def print_active_players(players, preferred_target):
    t = Table(title="ğŸ“¡ Active Players")
    t.add_column("Name")
    for p in players:
        marker = " [green](Target)[/]" if preferred_target and preferred_target in p else ""
        t.add_row(f"{p}{marker}")
    console.print(t)

def print_action_feedback(message, style="green"):
    """è½»é‡çº§æ“ä½œåé¦ˆ"""
    console.print(f"[{style}]âœ” {message}[/]")
```

## File: wait_games.py
```python
import time
import random
import sys
import select
import os
import importlib
import pkgutil
from rich.live import Live
from rich.panel import Panel
from rich.align import Align
import tty

# --- ğŸ® è¾“å…¥ç›‘å¬æ ¸å¿ƒ (é€šç”¨) ---
class InputHandler:
    @staticmethod
    def get_key():
        """
        æ£€æŸ¥æ˜¯å¦æœ‰æŒ‰é”®è¾“å…¥ï¼Œéé˜»å¡ã€‚
        è¿”å›: 'w', 'a', 's', 'd', ' ', 'p', or None
        """
        try:
            dr, dw, de = select.select([sys.stdin], [], [], 0)
            if dr:
                key = sys.stdin.read(1).lower()
                if key in ['\n', '\r']: return None
                return key
        except:
            pass
        return None

def get_all_games():
    """è·å–æ‰€æœ‰å¯ç”¨æ¸¸æˆæ¨¡å—åçš„åˆ—è¡¨"""
    game_folder = os.path.join(os.path.dirname(__file__), "games")
    return [name for _, name, _ in pkgutil.iter_modules([game_folder])]

def load_game(game_name):
    """åŠ è½½æŒ‡å®šåç§°çš„æ¸¸æˆ"""
    try:
        module = importlib.import_module(f"games.{game_name}")
        # å¼ºåˆ¶é‡æ–°åŠ è½½ï¼Œç¡®ä¿æ¯æ¬¡åˆ‡æ¢éƒ½èƒ½é‡ç½®çŠ¶æ€ (å¦‚æœæ˜¯å•ä¾‹æ¨¡å¼çš„è¯ï¼Œè™½ç„¶è¿™é‡Œæ˜¯å®ä¾‹åŒ–ç±»)
        importlib.reload(module)
        return module.Game(), game_name
    except Exception as e:
        return None, str(e)

# --- æ ¸å¿ƒè¿è¡Œé€»è¾‘ ---
def run_waiting_game(stop_event, ai_status=None):
    # é˜»æ­¢å›æ˜¾
    tty.setcbreak(sys.stdin.fileno())
    
    # 1. è·å–æ¸¸æˆåˆ—è¡¨
    available_games = get_all_games()

    if not available_games:
        from rich.console import Console
        Console().print("[red]No games found in /games folder[/]")
        while not stop_event.is_set(): time.sleep(1)
        return

    # 2. åˆå§‹éšæœºåŠ è½½ä¸€ä¸ª
    current_game_name = random.choice(available_games)
    game, name = load_game(current_game_name)

    if not game:
        from rich.console import Console
        Console().print(f"[red]Failed to load game: {name}[/]")
        return

    with Live(refresh_per_second=15, transient=True, auto_refresh=False) as live:
        step = 0
        while not stop_event.is_set():
            # è·å–æŒ‰é”®
            key = InputHandler.get_key()

            # --- [NEW] åˆ‡æ¢æ¸¸æˆé€»è¾‘ ---
            if key == 'p':
                # éšæœºé€‰ä¸€ä¸ªï¼ˆé™¤äº†å½“å‰è¿™ä¸ªï¼Œé˜²æ­¢åˆ‡åˆ°åŒä¸€ä¸ªï¼‰
                others = [g for g in available_games if g != current_game_name]
                if others:
                    current_game_name = random.choice(others)
                elif available_games:
                    current_game_name = available_games[0] # åªæœ‰ä¸€ä¸ªæ¸¸æˆæ—¶

                # é‡æ–°åŠ è½½æ–°æ¸¸æˆ
                game, name = load_game(current_game_name)
                step = 0 # é‡ç½®æ­¥æ•°
                key = None # æ¶ˆè€—æ‰æŒ‰é”®ï¼Œä¸ä¼ ç»™æ–°æ¸¸æˆ

            # --- æ­£å¸¸æ¸¸æˆé€»è¾‘ ---
            if key and game:
                game.handle_input(key)

            if game:
                renderable = game.render(step)

                # åŠ¨æ€ä¿®æ”¹ Panel subtitle æ˜¾ç¤º AI è¿›åº¦
                if ai_status and isinstance(renderable, Panel):
                    count = ai_status.get('count', 0)
                    # åœ¨åŸ subtitle åå¢åŠ åˆ‡æ¢æç¤º
                    base_sub = renderable.subtitle or ""
                    # é¿å…é‡å¤å åŠ æç¤º
                    if "[P] Switch" not in base_sub:
                        new_sub = f"{base_sub} | [dim]ğŸ§  AI: [bold cyan]{count}[/] chars | [P] Switch Game[/]"
                    else:
                        # å¦‚æœæ˜¯æ¸¸æˆè‡ªå¸¦çš„æ¸²æŸ“é€»è¾‘ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦ç¡¬è¦†ç›–æˆ–è€…ä¿ç•™ AI è®¡æ•°
                        new_sub = f"[dim]ğŸ§  AI: [bold cyan]{count}[/] chars | [P] Switch Game[/]"

                    renderable.subtitle = new_sub

                live.update(renderable, refresh=True)

            time.sleep(0.05)
            step += 1
```
